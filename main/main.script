local data = require('main.data')

local world = data.world

-- Cost per direction
local costs = {
    [130] = {
        1.0,  -- E
        1.0,  -- N
        1.0,  -- W
        1.0,  -- S
        1.41, -- NE
        1.41, -- NW
        1.41, -- SW
        1.41  -- SE
    }
}
-- SETUP
local map_width = 39
local map_height = 20
local direction = astar.DIRECTION_EIGHT

--[[
        allocate: How many states should be internally allocated at a time. This
        can be hard to get correct. The higher the value, the more memory
        Patfinder will use.

        - If you have a small map (a few thousand states?) it may make sense
        to pass in the maximum value. This will cache everything, and MicroPather
        will only need one main memory allocation. For a chess board, allocate
        would be set to 8x8 (64)

         - If your map is large, something like 1/4 the number of possible
         states is good.

         - If your state space is huge, use a multiple (5-10x) of the normal
         path. "Occasionally" call astar.reset_cache() to free unused memory.
]]
local allocate = map_width * map_height

--[[
        typicalAdjacent: Used to determine cache size. The typical number of adjacent states
        to a given state. (On a chessboard, 8.) Higher values use a little
        more memory.
]]
local typical_adjacent = 8

--[[
        cache: Turn on path caching. Uses more memory (yet again) but at a huge speed
        advantage if you may call the pather with the same path or sub-path, which
        is common for pathing over maps in games.
]]
local cache = true

-- Solve
local start_x = 1
local start_y = 18
local end_x = 17
local end_y = 2
local max_cost = 3.0 -- near

function init(self)
    astar.setup(map_width, map_height, direction, allocate, typical_adjacent, cache)
    astar.set_map(world)
    astar.set_costs(costs)

    --  astar.toogle_zero(true);

    local result, size, total_cost, path = astar.solve(start_x, start_y, end_x, end_y)

    print("size:", size)
    print("total_cost:", total_cost)

    if result == astar.SOLVED then
        print("SOLVED")
        for i, v in ipairs(path) do
            print("Tile: ", v.x .. "-" .. v.y)
        end
    elseif result == astar.NO_SOLUTION then
        print("NO_SOLUTION")
    elseif result == astar.START_END_SAME then
        print("START_END_SAME")
    end



    local near_result, near_size, nears = astar.solve_near(start_x, start_y, max_cost)

    print("near_size:", near_size)

    if near_result == astar.SOLVED then
        print("SOLVED")
        for i, v in ipairs(nears) do
            print("Tile: ", v.x .. "-" .. v.y)
        end
    elseif near_result == astar.NO_SOLUTION then
        print("NO_SOLUTION")
    elseif near_result == astar.START_END_SAME then
        print("START_END_SAME")
    end

    print("-------------------------")
end
